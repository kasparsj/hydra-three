import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import prettier from "prettier";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, "..", "..");

const checkMode = process.argv.includes("--check");

const readText = async (relativePath) => {
  return fs.readFile(path.join(rootDir, relativePath), "utf8");
};

const ensureDir = async (relativePath) => {
  await fs.mkdir(path.join(rootDir, relativePath), { recursive: true });
};

const extractBraceBlock = (source, marker) => {
  const start = source.indexOf(marker);
  if (start === -1) {
    throw new Error(`Could not find marker: ${marker}`);
  }

  const openIndex = source.indexOf("{", start);
  if (openIndex === -1) {
    throw new Error(`Could not find opening brace for marker: ${marker}`);
  }

  let depth = 1;
  for (let index = openIndex + 1; index < source.length; index += 1) {
    const char = source[index];
    if (char === "{") {
      depth += 1;
    } else if (char === "}") {
      depth -= 1;
      if (depth === 0) {
        return source.slice(openIndex + 1, index);
      }
    }
  }

  throw new Error(`Could not find closing brace for marker: ${marker}`);
};

const extractTopLevelMembers = (block) => {
  const members = [];
  const seen = new Set();

  block.split(/\r?\n/).forEach((line) => {
    const methodMatch = line.match(
      /^ {2}([A-Za-z_][A-Za-z0-9_]*)\??\s*(?:\(|:)/,
    );
    if (!methodMatch) {
      return;
    }
    const name = methodMatch[1];
    if (!seen.has(name)) {
      seen.add(name);
      members.push(name);
    }
  });

  return members;
};

const extractModuleExports = (source) => {
  const exportMatches = [...source.matchAll(/export\s*\{([\s\S]*?)\}\s*;?/g)];
  if (!exportMatches.length) {
    return [];
  }

  const exportList = exportMatches[exportMatches.length - 1][1];
  return exportList
    .replace(/\n/g, " ")
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean)
    .map((entry) => entry.replace(/\s+as\s+.*/, "").trim())
    .filter(Boolean);
};

const extractTransforms = (source) => {
  const lines = source.split(/\r?\n/);
  const startIndex = lines.findIndex((line) =>
    line.includes("export default () => ["),
  );
  if (startIndex === -1) {
    throw new Error("Could not find transform export list start");
  }

  const transforms = [];
  const seen = new Set();

  for (let index = startIndex; index < lines.length; index += 1) {
    const nameMatch = lines[index].match(/^\s{2,4}name:\s*'([^']+)'/);
    if (!nameMatch) {
      continue;
    }

    const name = nameMatch[1];
    if (seen.has(name)) {
      continue;
    }

    let type = "";
    for (
      let lookAhead = index + 1;
      lookAhead <= index + 12 && lookAhead < lines.length;
      lookAhead += 1
    ) {
      const typeMatch = lines[lookAhead].match(/^\s{2,4}type:\s*'([^']+)'/);
      if (typeMatch) {
        type = typeMatch[1];
        break;
      }
      if (lines[lookAhead].match(/^\s{2,4}name:\s*'/)) {
        break;
      }
    }

    if (!type) {
      continue;
    }

    seen.add(name);
    transforms.push({ name, type });
  }

  return transforms;
};

const toTransformTypeIndex = (transforms) => {
  const byType = {};
  transforms.forEach(({ name, type }) => {
    if (!byType[type]) {
      byType[type] = [];
    }
    byType[type].push(name);
  });

  Object.keys(byType).forEach((type) => {
    byType[type].sort((a, b) => a.localeCompare(b));
  });

  return byType;
};

const toMarkdown = (manifest, transforms, transformsByType) => {
  const moduleRows = Object.entries(manifest.modules)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([moduleName, methods]) => {
      return `| \`${moduleName}\` | ${methods.length} | ${methods.map((name) => `\`${name}\``).join(", ")} |`;
    })
    .join("\n");

  const typeSections = Object.entries(transformsByType)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([type, names]) => {
      return `### \`${type}\`\n\n${names.map((name) => `- \`${name}\``).join("\n")}`;
    })
    .join("\n\n");

  return `# API Reference (Generated)

This file is generated by \`npm run docs:generate\` from source-of-truth APIs in:

- \`src/index.d.ts\`
- \`src/glsl/glsl-functions.js\`
- module export files in \`src/three/*.js\`, \`src/gui.js\`, and \`src/el.js\`

Do not edit this file manually.

### Surface Summary

- Constructor options: **${manifest.constructorOptions.length}**
- \`HydraRenderer\` members: **${manifest.hydraRendererMembers.length}**
- \`HydraSynthApi\` members: **${manifest.hydraSynthMembers.length}**
- \`HydraSceneApi\` members: **${manifest.sceneMembers.length}**
- Transform chain members: **${manifest.transformChainMembers.length}**
- Module namespaces: **${Object.keys(manifest.modules).length}**
- GLSL transforms: **${transforms.length}**

### Constructor Options

${manifest.constructorOptions.map((name) => `- \`${name}\``).join("\n")}

### HydraRenderer Members

${manifest.hydraRendererMembers.map((name) => `- \`${name}\``).join("\n")}

### HydraSynthApi Members

${manifest.hydraSynthMembers.map((name) => `- \`${name}\``).join("\n")}

### HydraSceneApi Members

${manifest.sceneMembers.map((name) => `- \`${name}\``).join("\n")}

### Transform Chain Members

${manifest.transformChainMembers.map((name) => `- \`${name}\``).join("\n")}

### Module Namespaces

| Namespace | Export Count | Exports |
| --- | ---: | --- |
${moduleRows}

### Transform Catalog

${typeSections}
`;
};

const writeTargets = async (targets) => {
  const dirty = [];

  for (const { path: relativePath, content } of targets) {
    const absolutePath = path.join(rootDir, relativePath);
    let existingContent = null;
    try {
      existingContent = await fs.readFile(absolutePath, "utf8");
    } catch (_error) {
      existingContent = null;
    }

    if (existingContent !== content) {
      if (checkMode) {
        dirty.push(relativePath);
      } else {
        await fs.mkdir(path.dirname(absolutePath), { recursive: true });
        await fs.writeFile(absolutePath, content, "utf8");
      }
    }
  }

  if (checkMode && dirty.length > 0) {
    throw new Error(
      `Generated API docs are out of date:\n${dirty
        .map((entry) => `- ${entry}`)
        .join("\n")}\n\nRun: npm run docs:generate`,
    );
  }
};

const main = async () => {
  const typesSource = await readText("src/index.d.ts");
  const transformSource = await readText("src/glsl/glsl-functions.js");

  const moduleFiles = {
    gm: "src/three/gm.js",
    mt: "src/three/mt.js",
    tx: "src/three/tx.js",
    cmp: "src/three/cmp.js",
    rnd: "src/three/rnd.js",
    nse: "src/three/noise.js",
    arr: "src/three/arr.js",
    el: "src/el.js",
    gui: "src/gui.js",
    math: "src/three/math.js",
  };

  const constructorOptions = extractTopLevelMembers(
    extractBraceBlock(typesSource, "export interface HydraOptions {"),
  );

  const hydraRendererMembers = extractTopLevelMembers(
    extractBraceBlock(typesSource, "declare class HydraRenderer {"),
  );

  const hydraSynthMembers = extractTopLevelMembers(
    extractBraceBlock(typesSource, "export interface HydraSynthApi {"),
  );

  const sceneMembers = extractTopLevelMembers(
    extractBraceBlock(typesSource, "export interface HydraSceneApi {"),
  );

  const transformChainMembers = extractTopLevelMembers(
    extractBraceBlock(typesSource, "export interface HydraTransformChain {"),
  );

  const modules = {};
  const moduleEntries = Object.entries(moduleFiles);
  for (let index = 0; index < moduleEntries.length; index += 1) {
    const [moduleName, modulePath] = moduleEntries[index];
    modules[moduleName] = extractModuleExports(await readText(modulePath));
  }

  const transforms = extractTransforms(transformSource).sort((a, b) => {
    if (a.type === b.type) {
      return a.name.localeCompare(b.name);
    }
    return a.type.localeCompare(b.type);
  });
  const transformsByType = toTransformTypeIndex(transforms);

  const apiManifest = {
    constructorOptions,
    hydraRendererMembers,
    hydraSynthMembers,
    sceneMembers,
    transformChainMembers,
    modules,
    counts: {
      constructorOptions: constructorOptions.length,
      hydraRendererMembers: hydraRendererMembers.length,
      hydraSynthMembers: hydraSynthMembers.length,
      sceneMembers: sceneMembers.length,
      transformChainMembers: transformChainMembers.length,
      modules: Object.keys(modules).length,
      transforms: transforms.length,
    },
  };

  const markdown = await prettier.format(
    toMarkdown(apiManifest, transforms, transformsByType),
    { parser: "markdown" },
  );

  await ensureDir("docs/.generated");

  await writeTargets([
    {
      path: "docs/.generated/api-manifest.json",
      content: `${JSON.stringify(apiManifest, null, 2)}\n`,
    },
    {
      path: "docs/.generated/transforms.json",
      content: `${JSON.stringify({ transforms, byType: transformsByType }, null, 2)}\n`,
    },
    {
      path: "docs/api.md",
      content: markdown,
    },
  ]);

  if (!checkMode) {
    console.log("Generated API docs and manifests.");
  } else {
    console.log("Generated API docs are in sync.");
  }
};

await main();
